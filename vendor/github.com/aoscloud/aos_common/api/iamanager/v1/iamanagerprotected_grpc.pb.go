// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package iamanager

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// IAMProtectedServiceClient is the client API for IAMProtectedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IAMProtectedServiceClient interface {
	GetCertTypes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CertTypes, error)
	FinishProvisioning(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	Clear(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetOwner(ctx context.Context, in *SetOwnerRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*CreateKeyResponse, error)
	ApplyCert(ctx context.Context, in *ApplyCertRequest, opts ...grpc.CallOption) (*ApplyCertResponse, error)
	GetCert(ctx context.Context, in *GetCertRequest, opts ...grpc.CallOption) (*GetCertResponse, error)
	SetUsers(ctx context.Context, in *Users, opts ...grpc.CallOption) (*empty.Empty, error)
	RegisterService(ctx context.Context, in *RegisterServiceRequest, opts ...grpc.CallOption) (*RegisterServiceResponse, error)
	UnregisterService(ctx context.Context, in *UnregisterServiceRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	EncryptDisk(ctx context.Context, in *EncryptDiskRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type iAMProtectedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIAMProtectedServiceClient(cc grpc.ClientConnInterface) IAMProtectedServiceClient {
	return &iAMProtectedServiceClient{cc}
}

func (c *iAMProtectedServiceClient) GetCertTypes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CertTypes, error) {
	out := new(CertTypes)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/GetCertTypes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) FinishProvisioning(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/FinishProvisioning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) Clear(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/Clear", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) SetOwner(ctx context.Context, in *SetOwnerRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/SetOwner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*CreateKeyResponse, error) {
	out := new(CreateKeyResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/CreateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) ApplyCert(ctx context.Context, in *ApplyCertRequest, opts ...grpc.CallOption) (*ApplyCertResponse, error) {
	out := new(ApplyCertResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/ApplyCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) GetCert(ctx context.Context, in *GetCertRequest, opts ...grpc.CallOption) (*GetCertResponse, error) {
	out := new(GetCertResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/GetCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) SetUsers(ctx context.Context, in *Users, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/SetUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) RegisterService(ctx context.Context, in *RegisterServiceRequest, opts ...grpc.CallOption) (*RegisterServiceResponse, error) {
	out := new(RegisterServiceResponse)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/RegisterService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) UnregisterService(ctx context.Context, in *UnregisterServiceRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/UnregisterService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAMProtectedServiceClient) EncryptDisk(ctx context.Context, in *EncryptDiskRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iamanager.v1.IAMProtectedService/EncryptDisk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IAMProtectedServiceServer is the server API for IAMProtectedService service.
// All implementations must embed UnimplementedIAMProtectedServiceServer
// for forward compatibility
type IAMProtectedServiceServer interface {
	GetCertTypes(context.Context, *empty.Empty) (*CertTypes, error)
	FinishProvisioning(context.Context, *empty.Empty) (*empty.Empty, error)
	Clear(context.Context, *ClearRequest) (*empty.Empty, error)
	SetOwner(context.Context, *SetOwnerRequest) (*empty.Empty, error)
	CreateKey(context.Context, *CreateKeyRequest) (*CreateKeyResponse, error)
	ApplyCert(context.Context, *ApplyCertRequest) (*ApplyCertResponse, error)
	GetCert(context.Context, *GetCertRequest) (*GetCertResponse, error)
	SetUsers(context.Context, *Users) (*empty.Empty, error)
	RegisterService(context.Context, *RegisterServiceRequest) (*RegisterServiceResponse, error)
	UnregisterService(context.Context, *UnregisterServiceRequest) (*empty.Empty, error)
	EncryptDisk(context.Context, *EncryptDiskRequest) (*empty.Empty, error)
	mustEmbedUnimplementedIAMProtectedServiceServer()
}

// UnimplementedIAMProtectedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIAMProtectedServiceServer struct {
}

func (UnimplementedIAMProtectedServiceServer) GetCertTypes(context.Context, *empty.Empty) (*CertTypes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCertTypes not implemented")
}
func (UnimplementedIAMProtectedServiceServer) FinishProvisioning(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishProvisioning not implemented")
}
func (UnimplementedIAMProtectedServiceServer) Clear(context.Context, *ClearRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedIAMProtectedServiceServer) SetOwner(context.Context, *SetOwnerRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOwner not implemented")
}
func (UnimplementedIAMProtectedServiceServer) CreateKey(context.Context, *CreateKeyRequest) (*CreateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKey not implemented")
}
func (UnimplementedIAMProtectedServiceServer) ApplyCert(context.Context, *ApplyCertRequest) (*ApplyCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyCert not implemented")
}
func (UnimplementedIAMProtectedServiceServer) GetCert(context.Context, *GetCertRequest) (*GetCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCert not implemented")
}
func (UnimplementedIAMProtectedServiceServer) SetUsers(context.Context, *Users) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUsers not implemented")
}
func (UnimplementedIAMProtectedServiceServer) RegisterService(context.Context, *RegisterServiceRequest) (*RegisterServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterService not implemented")
}
func (UnimplementedIAMProtectedServiceServer) UnregisterService(context.Context, *UnregisterServiceRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterService not implemented")
}
func (UnimplementedIAMProtectedServiceServer) EncryptDisk(context.Context, *EncryptDiskRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptDisk not implemented")
}
func (UnimplementedIAMProtectedServiceServer) mustEmbedUnimplementedIAMProtectedServiceServer() {}

// UnsafeIAMProtectedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IAMProtectedServiceServer will
// result in compilation errors.
type UnsafeIAMProtectedServiceServer interface {
	mustEmbedUnimplementedIAMProtectedServiceServer()
}

func RegisterIAMProtectedServiceServer(s grpc.ServiceRegistrar, srv IAMProtectedServiceServer) {
	s.RegisterService(&IAMProtectedService_ServiceDesc, srv)
}

func _IAMProtectedService_GetCertTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).GetCertTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/GetCertTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).GetCertTypes(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_FinishProvisioning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).FinishProvisioning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/FinishProvisioning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).FinishProvisioning(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/Clear",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).Clear(ctx, req.(*ClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_SetOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).SetOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/SetOwner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).SetOwner(ctx, req.(*SetOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_CreateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).CreateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/CreateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).CreateKey(ctx, req.(*CreateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_ApplyCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).ApplyCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/ApplyCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).ApplyCert(ctx, req.(*ApplyCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_GetCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).GetCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/GetCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).GetCert(ctx, req.(*GetCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_SetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Users)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).SetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/SetUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).SetUsers(ctx, req.(*Users))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_RegisterService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).RegisterService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/RegisterService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).RegisterService(ctx, req.(*RegisterServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_UnregisterService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).UnregisterService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/UnregisterService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).UnregisterService(ctx, req.(*UnregisterServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAMProtectedService_EncryptDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAMProtectedServiceServer).EncryptDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iamanager.v1.IAMProtectedService/EncryptDisk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAMProtectedServiceServer).EncryptDisk(ctx, req.(*EncryptDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IAMProtectedService_ServiceDesc is the grpc.ServiceDesc for IAMProtectedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IAMProtectedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iamanager.v1.IAMProtectedService",
	HandlerType: (*IAMProtectedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCertTypes",
			Handler:    _IAMProtectedService_GetCertTypes_Handler,
		},
		{
			MethodName: "FinishProvisioning",
			Handler:    _IAMProtectedService_FinishProvisioning_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _IAMProtectedService_Clear_Handler,
		},
		{
			MethodName: "SetOwner",
			Handler:    _IAMProtectedService_SetOwner_Handler,
		},
		{
			MethodName: "CreateKey",
			Handler:    _IAMProtectedService_CreateKey_Handler,
		},
		{
			MethodName: "ApplyCert",
			Handler:    _IAMProtectedService_ApplyCert_Handler,
		},
		{
			MethodName: "GetCert",
			Handler:    _IAMProtectedService_GetCert_Handler,
		},
		{
			MethodName: "SetUsers",
			Handler:    _IAMProtectedService_SetUsers_Handler,
		},
		{
			MethodName: "RegisterService",
			Handler:    _IAMProtectedService_RegisterService_Handler,
		},
		{
			MethodName: "UnregisterService",
			Handler:    _IAMProtectedService_UnregisterService_Handler,
		},
		{
			MethodName: "EncryptDisk",
			Handler:    _IAMProtectedService_EncryptDisk_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "iamanager/v1/iamanagerprotected.proto",
}
